

Use scrypt or argon2 to derive a secure encryption key from the master password.-done

Store only the hash of the master password (never the password itself).-done

AES or ChaCha20 Encryption-done

Encrypt each password entry using AES-GCM or ChaCha20-Poly1305.-done

Use unique nonces/IVs for each entry to prevent pattern leaks.-done

Secure Storage

Store encrypted entries in a local file (e.g., JSON or BoltDB).

Optionally encrypt the entire file with a master key.

Clipboard Auto-Clear

Copy passwords to clipboard and auto-clear after a few seconds to reduce exposure.

Password Strength Meter

Evaluate password strength using entropy or pattern analysis.

Warn users about weak or reused passwords.

Audit Features

Track password age and flag old entries.

Optional breach check via public APIs (like HaveIBeenPwned).

Auto-Lock & Timeout

Lock the app after inactivity.

Require re-authentication to access stored data.

Import/Export with Encryption

Allow encrypted backups and secure imports.

Use password-protected export files.





Vault Creation (One-Time Setup)

Generate a random 32-byte challenge
→ Truly random (using crypto/rand), not derived from password.
Generate a random 16-byte salt
Derive a 32-byte encryption key from the master password:
textkey = Argon2id(master_password, salt, memory=64MiB, iterations=3, parallelism=4, keyLen=32)

Encrypt the random challenge using AES-256-GCM:

Generate a random 12-byte nonce
Encrypt: ciphertext || tag = AES-GCM(key, nonce, challenge)
Store: salt || nonce || ciphertext || tag


Encrypt the actual vault data (your passwords in JSON):

Generate a new random 12-byte nonce
Encrypt: vault_ciphertext || vault_tag = AES-GCM(key, new_nonce, vault_JSON)
Append to file:
textsalt || nonce1 || ct1 || tag1 || nonce2 || ct2 || tag2

1. User enters: username + password
2. DB: SELECT salt FROM users WHERE username = ?
3. Go: key = Argon2id(password, salt)
4. DB: SELECT encrypted_data, nonce FROM vaults WHERE user_id = ?
5. Go: plaintext = AES-GCM-Open(key, nonce, encrypted_data)
   → if fails → wrong password
   → if success → return vault JSON



Login / Unlock

Read file → extract:
salt, nonce1, ct1 || tag1, nonce2, ct2 || tag2
Derive key again:
textkey = Argon2id(input_password, salt, same_params)

Try to decrypt the challenge:
textAES-GCM-Decrypt(key, nonce1, ct1 || tag1)

If fails → Wrong password → Exit
If succeeds → Password is correct


Decrypt the vault:
textvault_JSON = AES-GCM-Decrypt(key, nonce2, ct2 || tag2)